/*
 * Copyright (C) 2003  Christian Cryder [christianc@granitepeaks.com]
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * $Id: DefaultEventContext.java 252 2013-02-21 18:15:44Z charleslowery $
 */
package org.barracudamvc.core.event;

import java.util.*;
import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.log4j.Logger;
import org.barracudamvc.core.view.ViewCapabilities;
import org.barracudamvc.plankton.data.DefaultStateMap;
import org.barracudamvc.plankton.data.ObjectRepository;
import org.barracudamvc.plankton.data.StateMap;
import org.barracudamvc.plankton.data.StateMapContainer;

/**
 * <p>The context contains information about the event (event, 
 * queue, plus request and response info if appropriate). The
 * context also implements StateMap, so you can use it to pass 
 * information between event handlers. The scope of the context 
 * is only for the duration of an event dispatch cycle (ie. from 
 * Http Request to Http Response)
 *
 * <p>Note that because DefaultEventContext implements ViewEventContext
 * it can safely be cast to its two parent interfaces: EventContext and
 * ControlEventContext. This is in fact what the DefaultEventDispatcher
 * actually does to control access to the appropriate information 
 * (ie. a ControlEvent handler should get a reference to an ControlEventContext,
 * NOT an ViewEventContext, since the control handlers shouldn't have
 * access to the HttpServletResponse object.)
 */
public class DefaultEventContext extends StateMapContainer implements ViewEventContext {
    /*
     * Note:
     * Persisting Context in a Soft Global Repository, rather than in the user 
     * session, which inherantly had problems if multiple frames on a client 
     * were firing different events at the same time. The down side of this 
     * is that the redirected url shows in the browser with something like 
     * this tacked onto the url: $ctxid=_1030135624563
     * 
     * The use of the Soft Global Repository was choosen as it allows for
     * the data to be cleaned up if the user never returns to claim the
     * resources stored.
     */
    
    //public vars
    protected static final Logger logger = Logger.getLogger(DefaultEventContext.class.getName());
    //private vars
    private static final String CONTEXT_ID = "$ctxid";
    private static final String STATE = "_STATE";
    private static final String LOCAL_OR = "_LOCAL_OR";
    private static long uid = System.currentTimeMillis();

    /**
     * Public constructor. 
     *
     * @param queue the event dispatch queue
     * @param config the servlet config structure
     * @param req the HttpServletRequest
     * @param resp the HttpServlet Response
     * @param defaultResponseEvent the default response event to be used 
     *        if none is generated by the control event handlers
     */
    public DefaultEventContext(DispatchQueue queue, ViewCapabilities vc,
            ServletConfig config,
            HttpServletRequest req,
            HttpServletResponse resp,
            HttpResponseEvent defaultResponseEvent) {
        restoreContext(req);
        this.putState(EventContext.DISPATCH_QUEUE, queue);
        this.putState(EventContext.VIEW_CAPABILITIES, vc);
        this.putState(ControlEventContext.SERVLET_CONFIG, config);
        this.putState(ControlEventContext.HTTP_SERVLET_REQUEST, req);
        this.putState(ViewEventContext.HTTP_SERVLET_RESPONSE, resp);
        this.putState(DefaultEventDispatcher.DEFAULT_RESPONSE_EVENT, defaultResponseEvent);
    }

    /**
     * Get the underlying BaseEvent
     *
     * @return the underlying BaseEvent
     */
    @Override
    public BaseEvent getEvent() {
        return (BaseEvent) this.getState(EventContext.BASE_EVENT);
    }

    /**
     * Get the underlying DispatchQueue
     *
     * @return the underlying DispatchQueue
     */
    @Override
    public DispatchQueue getQueue() {
        return (DispatchQueue) this.getState(EventContext.DISPATCH_QUEUE);
    }

    /**
     * Get the underlying ViewCapabilities
     */
    @Override
    public ViewCapabilities getViewCapabilities() {
        return (ViewCapabilities) this.getState(EventContext.VIEW_CAPABILITIES);
    }

    /**
     * Get the associated ServletConfig structure
     *
     * @return the associated ServletConfig structure
     */
    @Override
    public ServletConfig getConfig() {
        return (ServletConfig) this.getState(ControlEventContext.SERVLET_CONFIG);
    }

    /**
     * Get the associated HttpServletRequest
     *
     * @return the associated HttpServletRequest
     */
    @Override
    public HttpServletRequest getRequest() {
        return (HttpServletRequest) this.getState(ControlEventContext.HTTP_SERVLET_REQUEST);
    }

    /**
     * Get the associated HttpServletResponse
     *
     * @return the associated HttpServletResponse
     */
    @Override
    public HttpServletResponse getResponse() {
        return (HttpServletResponse) this.getState(ViewEventContext.HTTP_SERVLET_RESPONSE);
    }


    /**
     * The event context must be able to persist its state in the user's 
     * session. NOTE: this method is primarily intended for use by the 
     * EventDispatcher class when the system needs to persist context 
     * information over multiple request-response cycles (ie. to handle 
     * ClientSideRedirectExceptions). As such, developers using the event model 
     * in applications should never call this method.
     *
     * @param re the client side redirect exception that is the reason
     *  for this call to persistContext
     */
    @Override
    public void persistContext(ClientSideRedirectException re) {
        if (re.isPreventPersistContext()) {
            return;
        }

        if (logger.isInfoEnabled()) {
            logger.info("persisting event context");
        }

        ObjectRepository wgor = ObjectRepository.getSoftGlobalRepository();
        String id = getUID();

        // persist the statemap and local repository information in the soft 
        // global repository (note that the NS is what will keep this unique)
        // persisting statemap
        String stateMapKey = CONTEXT_ID + id + STATE;
        wgor.putState(stateMapKey, getStateMap());
        if (logger.isDebugEnabled()) {
            logger.debug("saved evemt context statemap, key: [" 
                    + stateMapKey + "] ");
        }

        // Local Repository
        ObjectRepository lr = ObjectRepository.getLocalRepository();
        Set keySet = lr.getStateKeys();
        if (keySet != null && keySet.size() > 0) {
            StateMap sm = new DefaultStateMap();
            String lorStateMapKey = CONTEXT_ID + id + LOCAL_OR;
            wgor.putState(lorStateMapKey, sm);
            if (logger.isDebugEnabled()) {
                logger.debug("saved Local Object Repository, key: ["
                        + lorStateMapKey + "] ");
            }
            for (Object key : keySet) {
                sm.putState(key, lr.getState(key));
            }
        }

        // finally, adjust the redirect url to ensure that we can extract the 
        // NS id from the url when it comes time to restore the context
        String url = re.getRedirectURL();
        int spos = url.indexOf("?");
        String sep = (spos > -1 ? "&" : "?");
        re.setRedirectURL(url + sep + CONTEXT_ID + "=" + id);
        if (logger.isDebugEnabled()) {
            logger.debug("adjusting redirect URL from: [" + url + "] to: [" 
                    + re.getRedirectURL() + "] ");
        }
    }

    /**
     * The event context must also be able to restore state
     * from the user's session. Calling this method effectively
     * removes the state from the session. 
     */
    private void restoreContext(HttpServletRequest req) {

        //start by trying to get the NS id from the request
        String id = req.getParameter(CONTEXT_ID);

        if (id == null) {
            setStateMap(new DefaultStateMap());
            return;
        }

        ObjectRepository wgor = ObjectRepository.getSoftGlobalRepository();
        // restore statemap
        String stkey = CONTEXT_ID + id + STATE;
        Object stateMapObject = wgor.getState(stkey);
        if (stateMapObject instanceof StateMap) {
            setStateMap((StateMap) stateMapObject);
        } else {
            setStateMap(new DefaultStateMap());
        }

        wgor.removeState(stkey);
        // restore local repository
        stkey = CONTEXT_ID + id + LOCAL_OR;
        Object lorStateMapObject = wgor.getState(stkey);
        if (lorStateMapObject instanceof StateMap) {
            StateMap localStateMap = (StateMap) lorStateMapObject;
            Set keySet = localStateMap.getStateKeys();
            if (keySet != null) {
                ObjectRepository lr = ObjectRepository.getLocalRepository();
                for (Object key : keySet) {
                    lr.putState(key, localStateMap.getState(key));
                }
            }
        }
        wgor.removeState(stkey);
    }

    private synchronized static String getUID() {
        return "_" + (++uid);
    }
}